<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>BeOnTrack - Deine Fitness Journey</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800;900&display=swap');
        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            color: #fff;
        }
        #scene-container {
            position: fixed;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* Top Stats */
        #top-bar {
            position: fixed;
            top: 0; left: 0; right: 0;
            padding: max(env(safe-area-inset-top), 12px) 20px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 20;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
        }
        .top-stat {
            text-align: center;
        }
        .top-stat-value {
            font-size: 22px;
            font-weight: 800;
            color: #00aaff;
            text-shadow: 0 0 20px rgba(0,170,255,0.5);
        }
        .top-stat-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255,255,255,0.35);
            margin-top: 2px;
        }

        /* Bottom Navigation */
        #bottom-nav {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.92);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 1px solid rgba(0,170,255,0.15);
            display: flex;
            justify-content: space-around;
            padding: 8px 0;
            padding-bottom: max(8px, env(safe-area-inset-bottom));
            z-index: 20;
        }
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s, transform 0.2s;
            padding: 4px 12px;
            border: none;
            background: none;
            color: #fff;
        }
        .nav-item:active { transform: scale(0.9); }
        .nav-item.active {
            opacity: 1;
            color: #00aaff;
        }
        .nav-item svg { width: 24px; height: 24px; }
        .nav-label {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Workout Add Button */
        #add-workout-btn {
            position: fixed;
            right: 20px;
            bottom: 90px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #0066ff, #00aaff);
            border: none;
            color: #fff;
            font-size: 28px;
            font-weight: 300;
            cursor: pointer;
            z-index: 21;
            box-shadow: 0 4px 30px rgba(0,170,255,0.4), 0 0 60px rgba(0,170,255,0.15);
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #add-workout-btn:active {
            transform: scale(0.9);
            box-shadow: 0 2px 15px rgba(0,170,255,0.3);
        }

        /* Milestone Popup */
        #milestone-popup {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s;
        }
        #milestone-popup.show {
            opacity: 1;
            pointer-events: auto;
        }
        .milestone-card {
            background: linear-gradient(135deg, rgba(0,100,255,0.15), rgba(0,170,255,0.08));
            border: 1px solid rgba(0,170,255,0.3);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            max-width: 320px;
            transform: scale(0.8);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #milestone-popup.show .milestone-card { transform: scale(1); }
        .milestone-card h2 {
            font-size: 56px;
            font-weight: 900;
            color: #00aaff;
            text-shadow: 0 0 40px rgba(0,170,255,0.5);
        }
        .milestone-card p {
            color: rgba(255,255,255,0.6);
            font-size: 16px;
            margin-top: 8px;
        }
        .milestone-card button {
            margin-top: 24px;
            background: linear-gradient(135deg, #0066ff, #00aaff);
            color: #fff;
            border: none;
            padding: 14px 40px;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            font-family: inherit;
        }

        /* Confetti */
        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
        }
        .confetti {
            position: fixed;
            z-index: 99;
            pointer-events: none;
            animation: confetti-fall 3s ease-in forwards;
        }

        /* Scroll hint */
        #scroll-hint {
            position: fixed;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.2);
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
            z-index: 15;
            animation: pulse-hint 2s infinite;
        }
        @keyframes pulse-hint {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>

    <!-- Top Stats -->
    <div id="top-bar">
        <div class="top-stat">
            <div class="top-stat-value" id="stat-workouts">0</div>
            <div class="top-stat-label">Workouts</div>
        </div>
        <div class="top-stat">
            <div class="top-stat-value" id="stat-streak">0</div>
            <div class="top-stat-label">Streak</div>
        </div>
        <div class="top-stat">
            <div class="top-stat-value" id="stat-volume">0</div>
            <div class="top-stat-label">Tonnen</div>
        </div>
    </div>

    <!-- FAB -->
    <button id="add-workout-btn">+</button>

    <div id="scroll-hint">Wischen zum Scrollen</div>

    <!-- Bottom Nav -->
    <nav id="bottom-nav">
        <button class="nav-item" data-tab="profil">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8"><path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
            <span class="nav-label">Profil</span>
        </button>
        <button class="nav-item" data-tab="suche">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>
            <span class="nav-label">Suche</span>
        </button>
        <button class="nav-item active" data-tab="track">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>
            <span class="nav-label">Track</span>
        </button>
        <button class="nav-item" data-tab="workout">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8"><circle cx="12" cy="12" r="10"/><path d="M12 8v8m-4-4h8"/></svg>
            <span class="nav-label">Workout</span>
        </button>
        <button class="nav-item" data-tab="stats">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8"><path d="M18 20V10M12 20V4M6 20v-6"/></svg>
            <span class="nav-label">Vol. Rechner</span>
        </button>
    </nav>

    <!-- Milestone Popup -->
    <div id="milestone-popup">
        <div class="milestone-card">
            <h2 id="ms-title"></h2>
            <p id="ms-text"></p>
            <button onclick="document.getElementById('milestone-popup').classList.remove('show')">Weiter!</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // ===== DATA =====
    const MILESTONES = [1, 5, 10, 25, 50, 75, 100, 150, 200, 365];
    const WORKOUT_TYPES = [
        'BRUST, TRIZEPS', 'RUECKEN, BIZEPS', 'BEINE, SCHULTERN',
        'PUSH DAY', 'PULL DAY', 'LEG DAY', 'CARDIO', 'HIIT',
        'OBERKÖRPER', 'GANZKÖRPER'
    ];
    const WORKOUT_STATUS = ['Workout abgeschlossen', 'Workout geplant', 'Workout abgeschlossen'];

    let data = JSON.parse(localStorage.getItem('bot3d_data') || 'null') || { workouts: [] };
    let reachedMs = JSON.parse(localStorage.getItem('bot3d_ms') || '[]');

    if (data.workouts.length === 0) {
        for (let i = 14; i >= 0; i--) {
            if (Math.random() > 0.35) {
                const d = new Date(Date.now() - i * 86400000);
                data.workouts.push({
                    date: d.toISOString(),
                    type: WORKOUT_TYPES[Math.floor(Math.random() * WORKOUT_TYPES.length)],
                    status: 'Workout abgeschlossen',
                    duration: 40 + Math.floor(Math.random() * 50)
                });
            }
        }
        // Add a planned future workout
        const tomorrow = new Date(Date.now() + 86400000);
        data.workouts.push({
            date: tomorrow.toISOString(),
            type: WORKOUT_TYPES[Math.floor(Math.random() * WORKOUT_TYPES.length)],
            status: 'Workout geplant',
            duration: 0
        });
        const count = data.workouts.length;
        MILESTONES.forEach(m => { if (count >= m) reachedMs.push(m); });
        saveData();
    }

    function saveData() {
        localStorage.setItem('bot3d_data', JSON.stringify(data));
        localStorage.setItem('bot3d_ms', JSON.stringify(reachedMs));
    }

    function calcStreak() {
        let streak = 0;
        const today = new Date().setHours(0,0,0,0);
        let check = today;
        const dates = data.workouts.filter(w => w.status !== 'Workout geplant')
            .map(w => new Date(w.date).setHours(0,0,0,0));
        const unique = [...new Set(dates)].sort((a,b) => b - a);
        for (const d of unique) {
            if (d === check || d === check - 86400000) { streak++; check = d; }
            else if (d < check - 86400000) break;
        }
        return streak;
    }

    function formatDate(iso) {
        const d = new Date(iso);
        return d.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric' });
    }

    // ===== THREE.JS SCENE =====
    const container = document.getElementById('scene-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000510, 0.035);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2.8, 5.5);
    camera.lookAt(0, 1.2, -2);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);

    // ===== LIGHTS =====
    // Blue atmospheric back light
    const backLight = new THREE.PointLight(0x0066ff, 8, 30);
    backLight.position.set(0, 6, -15);
    scene.add(backLight);

    const backLight2 = new THREE.PointLight(0x0044cc, 4, 20);
    backLight2.position.set(-3, 3, -10);
    scene.add(backLight2);

    const backLight3 = new THREE.PointLight(0x0088ff, 3, 20);
    backLight3.position.set(3, 3, -10);
    scene.add(backLight3);

    // Subtle rim light on figure
    const rimLight = new THREE.SpotLight(0x0077ff, 3, 15, Math.PI / 4, 0.5);
    rimLight.position.set(0, 5, -5);
    rimLight.target.position.set(0, 1, 0);
    scene.add(rimLight);
    scene.add(rimLight.target);

    // Ambient
    const ambient = new THREE.AmbientLight(0x001133, 0.5);
    scene.add(ambient);

    // Ground glow
    const groundLight = new THREE.PointLight(0x003388, 2, 8);
    groundLight.position.set(0, 0.1, 0);
    scene.add(groundLight);

    // ===== REFLECTIVE GROUND =====
    const groundGeo = new THREE.PlaneGeometry(40, 60);
    const groundMat = new THREE.MeshPhongMaterial({
        color: 0x000815,
        specular: 0x003366,
        shininess: 80,
        transparent: true,
        opacity: 0.9,
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.01;
    scene.add(ground);

    // ===== GRID LINES =====
    const gridHelper = new THREE.GridHelper(40, 80, 0x001a44, 0x000d22);
    gridHelper.position.y = 0.01;
    scene.add(gridHelper);

    // ===== FIGURE (Silhouette) =====
    const figureGroup = new THREE.Group();

    // Body (torso)
    const torsoGeo = new THREE.CylinderGeometry(0.32, 0.38, 1.1, 8);
    const figureMat = new THREE.MeshPhongMaterial({
        color: 0x050810,
        specular: 0x0033aa,
        shininess: 30,
        emissive: 0x000205,
    });
    const torso = new THREE.Mesh(torsoGeo, figureMat);
    torso.position.y = 1.35;
    figureGroup.add(torso);

    // Head (with hood shape)
    const headGeo = new THREE.SphereGeometry(0.25, 12, 12);
    const head = new THREE.Mesh(headGeo, figureMat);
    head.position.y = 2.1;
    head.scale.set(1, 1.1, 1);
    figureGroup.add(head);

    // Hood
    const hoodGeo = new THREE.SphereGeometry(0.32, 12, 8, 0, Math.PI * 2, 0, Math.PI * 0.6);
    const hood = new THREE.Mesh(hoodGeo, figureMat);
    hood.position.y = 2.15;
    hood.position.z = -0.02;
    hood.scale.set(1, 1.15, 1.2);
    figureGroup.add(hood);

    // Neck
    const neckGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.2, 8);
    const neck = new THREE.Mesh(neckGeo, figureMat);
    neck.position.y = 1.92;
    figureGroup.add(neck);

    // Arms
    const armGeo = new THREE.CylinderGeometry(0.09, 0.11, 0.85, 6);
    const leftArm = new THREE.Mesh(armGeo, figureMat);
    leftArm.position.set(-0.45, 1.25, 0);
    leftArm.rotation.z = 0.12;
    figureGroup.add(leftArm);
    const rightArm = new THREE.Mesh(armGeo, figureMat);
    rightArm.position.set(0.45, 1.25, 0);
    rightArm.rotation.z = -0.12;
    figureGroup.add(rightArm);

    // Forearms
    const forearmGeo = new THREE.CylinderGeometry(0.07, 0.09, 0.7, 6);
    const leftForearm = new THREE.Mesh(forearmGeo, figureMat);
    leftForearm.position.set(-0.48, 0.55, 0.05);
    leftForearm.rotation.z = 0.05;
    figureGroup.add(leftForearm);
    const rightForearm = new THREE.Mesh(forearmGeo, figureMat);
    rightForearm.position.set(0.48, 0.55, 0.05);
    rightForearm.rotation.z = -0.05;
    figureGroup.add(rightForearm);

    // Legs
    const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 1.0, 6);
    const leftLeg = new THREE.Mesh(legGeo, figureMat);
    leftLeg.position.set(-0.18, 0.42, 0);
    figureGroup.add(leftLeg);
    const rightLeg = new THREE.Mesh(legGeo.clone(), figureMat);
    rightLeg.position.set(0.18, 0.42, 0);
    figureGroup.add(rightLeg);

    // Feet
    const footGeo = new THREE.BoxGeometry(0.14, 0.08, 0.28);
    const leftFoot = new THREE.Mesh(footGeo, figureMat);
    leftFoot.position.set(-0.18, -0.04, 0.05);
    figureGroup.add(leftFoot);
    const rightFoot = new THREE.Mesh(footGeo, figureMat);
    rightFoot.position.set(0.18, -0.04, 0.05);
    figureGroup.add(rightFoot);

    // Shoulders
    const shoulderGeo = new THREE.SphereGeometry(0.16, 8, 8);
    const leftShoulder = new THREE.Mesh(shoulderGeo, figureMat);
    leftShoulder.position.set(-0.42, 1.72, 0);
    figureGroup.add(leftShoulder);
    const rightShoulder = new THREE.Mesh(shoulderGeo, figureMat);
    rightShoulder.position.set(0.42, 1.72, 0);
    figureGroup.add(rightShoulder);

    figureGroup.position.set(0, 0, 0);
    scene.add(figureGroup);

    // ===== WORKOUT PANELS =====
    let panelMeshes = [];
    let panelGlows = [];

    function createTextCanvas(text1, text2, text3, isPlanned) {
        const c = document.createElement('canvas');
        c.width = 512;
        c.height = 160;
        const x = c.getContext('2d');

        // Background
        x.fillStyle = 'rgba(0,10,30,0.6)';
        x.fillRect(0, 0, 512, 160);

        // Border
        const borderColor = isPlanned ? 'rgba(0,150,255,0.6)' : 'rgba(0,100,255,0.3)';
        x.strokeStyle = borderColor;
        x.lineWidth = 2;
        x.strokeRect(2, 2, 508, 156);

        // Corner accents
        x.strokeStyle = isPlanned ? 'rgba(0,170,255,0.8)' : 'rgba(0,120,255,0.5)';
        x.lineWidth = 3;
        const cl = 20;
        // Top-left
        x.beginPath(); x.moveTo(2,cl); x.lineTo(2,2); x.lineTo(cl,2); x.stroke();
        // Top-right
        x.beginPath(); x.moveTo(510-cl,2); x.lineTo(510,2); x.lineTo(510,cl); x.stroke();
        // Bottom-left
        x.beginPath(); x.moveTo(2,158-cl); x.lineTo(2,158); x.lineTo(cl,158); x.stroke();
        // Bottom-right
        x.beginPath(); x.moveTo(510-cl,158); x.lineTo(510,158); x.lineTo(510,158-cl); x.stroke();

        // Text
        x.textAlign = 'center';

        // Workout type
        x.font = 'bold 36px Inter, sans-serif';
        x.fillStyle = isPlanned ? 'rgba(255,255,255,0.95)' : 'rgba(255,255,255,0.7)';
        x.fillText(text1, 256, 55);

        // Status
        x.font = '300 18px Inter, sans-serif';
        x.fillStyle = isPlanned ? 'rgba(0,180,255,0.8)' : 'rgba(255,255,255,0.35)';
        x.fillText(text2, 256, 90);

        // Date
        x.font = '600 28px Inter, sans-serif';
        x.fillStyle = isPlanned ? 'rgba(0,200,255,0.9)' : 'rgba(0,150,255,0.6)';
        x.fillText(text3, 256, 130);

        return c;
    }

    function buildPanels() {
        // Remove old panels
        panelMeshes.forEach(m => scene.remove(m));
        panelGlows.forEach(m => scene.remove(m));
        panelMeshes = [];
        panelGlows = [];

        const workouts = [...data.workouts].reverse();

        workouts.forEach((w, i) => {
            const isPlanned = w.status === 'Workout geplant';
            const isCurrent = i === 0;

            const canvas = createTextCanvas(
                w.type,
                w.status,
                formatDate(w.date),
                isCurrent
            );

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;

            const panelGeo = new THREE.PlaneGeometry(3.2, 1.0);
            const panelMat = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: isCurrent ? 1.0 : Math.max(0.15, 0.8 - i * 0.08),
                side: THREE.DoubleSide,
            });

            const panel = new THREE.Mesh(panelGeo, panelMat);
            const z = -1.5 - i * 1.8;
            panel.position.set(0, 0.02, z);
            panel.rotation.x = -Math.PI / 2;
            scene.add(panel);
            panelMeshes.push(panel);

            // Glow edge for current/recent panels
            if (i < 4) {
                const glowGeo = new THREE.PlaneGeometry(3.4, 1.15);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: isCurrent ? 0x0088ff : 0x003366,
                    transparent: true,
                    opacity: isCurrent ? 0.25 : 0.08,
                    side: THREE.DoubleSide,
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.set(0, 0.01, z);
                glow.rotation.x = -Math.PI / 2;
                scene.add(glow);
                panelGlows.push(glow);
            }

            // Reflection (flipped, faded)
            if (i < 5) {
                const refMat = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: Math.max(0.03, 0.12 - i * 0.02),
                    side: THREE.DoubleSide,
                });
                const ref = new THREE.Mesh(panelGeo.clone(), refMat);
                ref.position.set(0, -0.03, z);
                ref.rotation.x = Math.PI / 2;
                scene.add(ref);
                panelMeshes.push(ref);
            }
        });
    }

    buildPanels();

    // ===== ATMOSPHERIC PARTICLES =====
    const particleCount = 100;
    const particleGeo = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);

    for (let i = 0; i < particleCount; i++) {
        particlePositions[i * 3] = (Math.random() - 0.5) * 20;
        particlePositions[i * 3 + 1] = Math.random() * 8;
        particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 30 - 5;
        particleSizes[i] = Math.random() * 3 + 1;
    }
    particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

    const particleMat = new THREE.PointsMaterial({
        color: 0x0066cc,
        size: 0.06,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });
    const particleSystem = new THREE.Points(particleGeo, particleMat);
    scene.add(particleSystem);

    // ===== BLUE VOLUMETRIC RAYS (simulated) =====
    for (let i = 0; i < 5; i++) {
        const rayGeo = new THREE.PlaneGeometry(0.3 + Math.random() * 0.5, 15);
        const rayMat = new THREE.MeshBasicMaterial({
            color: 0x0055cc,
            transparent: true,
            opacity: 0.03 + Math.random() * 0.03,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
            depthWrite: false,
        });
        const ray = new THREE.Mesh(rayGeo, rayMat);
        ray.position.set((Math.random() - 0.5) * 6, 4, -12 + Math.random() * 4);
        ray.rotation.z = (Math.random() - 0.5) * 0.3;
        scene.add(ray);
    }

    // ===== SCROLL / DRAG =====
    let scrollY = 0;
    let targetScrollY = 0;
    let dragActive = false;
    let dragLastY = 0;
    let velocity = 0;

    const maxScroll = Math.max(0, (data.workouts.length - 2) * 1.8);

    renderer.domElement.addEventListener('pointerdown', (e) => {
        dragActive = true;
        dragLastY = e.clientY;
        velocity = 0;
    });
    renderer.domElement.addEventListener('pointermove', (e) => {
        if (!dragActive) return;
        const dy = e.clientY - dragLastY;
        targetScrollY -= dy * 0.012;
        velocity = -dy * 0.012;
        dragLastY = e.clientY;
    });
    renderer.domElement.addEventListener('pointerup', () => { dragActive = false; });
    renderer.domElement.addEventListener('pointerleave', () => { dragActive = false; });

    renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        targetScrollY += e.deltaY * 0.005;
    }, { passive: false });

    // ===== RESIZE =====
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ===== UI =====
    function updateUI() {
        const completed = data.workouts.filter(w => w.status !== 'Workout geplant').length;
        document.getElementById('stat-workouts').textContent = completed;
        document.getElementById('stat-streak').textContent = calcStreak();
        document.getElementById('stat-volume').textContent = (completed * 2.4).toFixed(1);
    }
    updateUI();

    // Nav items
    document.querySelectorAll('.nav-item').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.nav-item').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        });
    });

    // Add workout
    document.getElementById('add-workout-btn').addEventListener('click', () => {
        const w = {
            date: new Date().toISOString(),
            type: WORKOUT_TYPES[Math.floor(Math.random() * WORKOUT_TYPES.length)],
            status: 'Workout abgeschlossen',
            duration: 40 + Math.floor(Math.random() * 50)
        };
        data.workouts.push(w);
        saveData();
        buildPanels();
        updateUI();

        // Scroll hint removal
        const hint = document.getElementById('scroll-hint');
        if (hint) hint.style.display = 'none';

        // Check milestones
        const count = data.workouts.filter(x => x.status !== 'Workout geplant').length;
        MILESTONES.forEach(m => {
            if (count === m && !reachedMs.includes(m)) {
                reachedMs.push(m);
                saveData();
                setTimeout(() => {
                    document.getElementById('ms-title').textContent = m + ' Workouts!';
                    document.getElementById('ms-text').textContent = getMsMsg(m);
                    document.getElementById('milestone-popup').classList.add('show');
                    spawnConfetti();
                }, 300);
            }
        });
    });

    function getMsMsg(c) {
        const m = { 1:'Erster Schritt!', 5:'Fuenf am Stueck!', 10:'Zweistellig!', 25:'Viertel-Hundert!',
            50:'Halbzeit!', 75:'Drei Viertel!', 100:'HUNDERT!', 150:'Wahnsinn!', 200:'Zweihundert!', 365:'LEGENDE!' };
        return m[c] || 'Meilenstein!';
    }

    function spawnConfetti() {
        const colors = ['#0088ff','#00aaff','#0055cc','#00ddff','#ffffff','#0066ff'];
        for (let i = 0; i < 50; i++) {
            const el = document.createElement('div');
            el.className = 'confetti';
            el.style.left = Math.random() * 100 + 'vw';
            el.style.width = (4 + Math.random() * 8) + 'px';
            el.style.height = (4 + Math.random() * 8) + 'px';
            el.style.background = colors[Math.floor(Math.random() * colors.length)];
            el.style.borderRadius = Math.random() > 0.5 ? '50%' : '1px';
            el.style.animationDelay = (Math.random() * 1.5) + 's';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 5000);
        }
    }

    // ===== ANIMATION LOOP =====
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        const dt = Math.min(clock.getDelta(), 0.05);

        // Scroll physics
        if (!dragActive) {
            velocity *= 0.92;
            targetScrollY += velocity;
        }
        targetScrollY = Math.max(-1, Math.min(maxScroll + 2, targetScrollY));
        scrollY += (targetScrollY - scrollY) * 0.08;

        // Move panels with scroll
        panelMeshes.forEach(m => {
            m.position.z += (scrollY - (m.userData.lastScroll || 0));
            m.userData.lastScroll = scrollY;
        });
        panelGlows.forEach(m => {
            m.position.z += (scrollY - (m.userData.lastScroll || 0));
            m.userData.lastScroll = scrollY;
        });

        // Actually just reposition based on scroll
        const workouts = [...data.workouts].reverse();
        let meshIdx = 0;
        workouts.forEach((w, i) => {
            const z = -1.5 - i * 1.8 + scrollY;
            if (panelMeshes[meshIdx]) {
                panelMeshes[meshIdx].position.z = z;
                meshIdx++;
            }
            // Reflection
            if (i < 5 && panelMeshes[meshIdx]) {
                panelMeshes[meshIdx].position.z = z;
                meshIdx++;
            }
        });

        let glowIdx = 0;
        workouts.forEach((w, i) => {
            if (i < 4 && panelGlows[glowIdx]) {
                panelGlows[glowIdx].position.z = -1.5 - i * 1.8 + scrollY;
                glowIdx++;
            }
        });

        // Figure subtle breathing
        figureGroup.position.y = Math.sin(t * 1.5) * 0.015;

        // Light pulsing
        backLight.intensity = 8 + Math.sin(t * 0.8) * 1.5;
        groundLight.intensity = 2 + Math.sin(t * 1.2) * 0.5;

        // Panel glow pulse
        panelGlows.forEach((g, i) => {
            if (i === 0) {
                g.material.opacity = 0.2 + Math.sin(t * 2) * 0.08;
            }
        });

        // Particles float
        const positions = particleSystem.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3 + 1] += Math.sin(t + i) * 0.002;
            positions[i * 3] += Math.cos(t * 0.5 + i * 0.3) * 0.001;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
        particleMat.opacity = 0.3 + Math.sin(t * 0.7) * 0.1;

        renderer.render(scene, camera);
    }

    animate();
    </script>
</body>
</html>
