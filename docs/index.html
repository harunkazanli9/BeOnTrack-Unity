<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#141828">
    <title>BeOnTrack - Deine Fitness Journey</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #141828;
            overflow: hidden;
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        #stats-bar {
            position: fixed;
            top: 0; left: 0; right: 0;
            background: linear-gradient(180deg, rgba(20,24,40,0.95) 0%, rgba(20,24,40,0) 100%);
            padding: 12px 16px 24px;
            display: flex;
            justify-content: space-around;
            pointer-events: auto;
            z-index: 11;
        }
        .stat-item {
            text-align: center;
            color: #fff;
        }
        .stat-value {
            font-size: 28px;
            font-weight: 800;
            background: linear-gradient(135deg, #4DE680, #00D4FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.5);
            margin-top: 2px;
        }
        #bottom-bar {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(0deg, rgba(20,24,40,0.95) 0%, rgba(20,24,40,0) 100%);
            padding: 24px 16px 16px;
            display: flex;
            justify-content: center;
            gap: 12px;
            pointer-events: auto;
            z-index: 11;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
        }
        .btn {
            border: none;
            border-radius: 16px;
            padding: 14px 20px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .btn:active { transform: scale(0.95); }
        .btn-primary {
            background: linear-gradient(135deg, #4DE680, #00D4FF);
            color: #141828;
            box-shadow: 0 4px 20px rgba(77, 230, 128, 0.3);
            flex: 1;
            justify-content: center;
            max-width: 200px;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            width: 52px;
            height: 52px;
            padding: 0;
            justify-content: center;
            border-radius: 50%;
        }
        #milestone-popup {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(77,230,128,0.15), rgba(0,212,255,0.15));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(77,230,128,0.3);
            border-radius: 24px;
            padding: 32px;
            text-align: center;
            color: #fff;
            z-index: 100;
            pointer-events: auto;
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #milestone-popup.show { transform: translate(-50%, -50%) scale(1); }
        #milestone-popup h2 {
            font-size: 48px;
            margin-bottom: 8px;
        }
        #milestone-popup p {
            font-size: 18px;
            color: rgba(255,255,255,0.7);
        }
        #milestone-popup .close-btn {
            margin-top: 20px;
            background: linear-gradient(135deg, #4DE680, #00D4FF);
            color: #141828;
            border: none;
            padding: 12px 32px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
        }
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            z-index: 99;
            pointer-events: none;
            animation: confetti-fall 3s ease-in forwards;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>

    <div id="ui-overlay">
        <div id="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="workout-count">0</div>
                <div class="stat-label">Workouts</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="streak-count">0</div>
                <div class="stat-label">Streak</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="distance-count">0m</div>
                <div class="stat-label">Strecke</div>
            </div>
        </div>

        <div id="bottom-bar">
            <button class="btn btn-secondary" id="btn-start" title="Zum Start">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="11 17 6 12 11 7"/><polyline points="18 17 13 12 18 7"/></svg>
            </button>
            <button class="btn btn-primary" id="btn-workout">+ WORKOUT</button>
            <button class="btn btn-secondary" id="btn-focus" title="Zum Avatar">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4m10-10h-4M6 12H2"/></svg>
            </button>
            <button class="btn btn-secondary" id="btn-screenshot" title="Screenshot">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/><circle cx="12" cy="13" r="4"/></svg>
            </button>
        </div>
    </div>

    <div id="milestone-popup">
        <h2 id="milestone-title"></h2>
        <p id="milestone-text"></p>
        <button class="close-btn" onclick="closeMilestone()">Weiter!</button>
    </div>

    <script>
    // ===== GAME ENGINE =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H, dpr;
    function resize() {
        dpr = window.devicePixelRatio || 1;
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // ===== DATA =====
    const MILESTONES = [1, 5, 10, 25, 50, 75, 100, 150, 200, 365];
    const MILESTONE_COLORS = ['#4DE680','#00D4FF','#FFD700','#FF6B9D','#A855F7','#FF8C42','#00E5FF','#FF4081','#76FF03','#E040FB'];
    const WORKOUT_TYPES = ['Krafttraining', 'Cardio', 'HIIT', 'Yoga', 'Laufen'];

    let workoutData = JSON.parse(localStorage.getItem('beontrack_data') || 'null') || { workouts: [], streak: 0 };
    let reachedMilestones = JSON.parse(localStorage.getItem('beontrack_milestones') || '[]');

    function saveData() {
        localStorage.setItem('beontrack_data', JSON.stringify(workoutData));
        localStorage.setItem('beontrack_milestones', JSON.stringify(reachedMilestones));
    }

    // Generate sample data if empty
    if (workoutData.workouts.length === 0) {
        for (let i = 20; i >= 0; i--) {
            if (Math.random() > 0.4) {
                workoutData.workouts.push({
                    date: new Date(Date.now() - i * 86400000).toISOString(),
                    type: WORKOUT_TYPES[Math.floor(Math.random() * WORKOUT_TYPES.length)],
                    duration: 20 + Math.floor(Math.random() * 70)
                });
            }
        }
        // Mark milestones already passed
        const count = workoutData.workouts.length;
        MILESTONES.forEach(m => { if (count >= m) reachedMilestones.push(m); });
        saveData();
    }

    function calcStreak() {
        let streak = 0;
        const today = new Date().setHours(0,0,0,0);
        let checkDate = today;
        const dates = workoutData.workouts.map(w => new Date(w.date).setHours(0,0,0,0));
        const uniqueDates = [...new Set(dates)].sort((a,b) => b - a);

        for (let d of uniqueDates) {
            if (d === checkDate || d === checkDate - 86400000) {
                streak++;
                checkDate = d;
            } else if (d < checkDate - 86400000) break;
        }
        return streak;
    }

    // ===== CAMERA =====
    let camera = { x: 0, y: 0, zoom: 1, targetX: 0, targetY: 0, velX: 0, velY: 0 };
    let isDragging = false, dragStartX = 0, dragStartY = 0, lastDragX = 0, lastDragY = 0;
    let autoFollow = true, autoFollowTimer = 0;

    // ===== PATH =====
    const STEP_SIZE = 3;
    const CURVE_FREQ = 0.08;
    const CURVE_AMP = 2.5;

    function getPathPoint(t) {
        const x = t * STEP_SIZE;
        const y = Math.sin(t * CURVE_FREQ) * CURVE_AMP + Math.sin(t * CURVE_FREQ * 0.5) * CURVE_AMP * 0.5;
        return { x, y };
    }

    // ===== AVATAR =====
    let avatar = { x: 0, y: 0, targetX: 0, targetY: 0, bounce: 0, isMoving: false, breathe: 0 };

    function updateAvatarTarget() {
        const count = workoutData.workouts.length;
        const p = getPathPoint(count);
        avatar.targetX = p.x;
        avatar.targetY = p.y;
    }
    updateAvatarTarget();
    // Set initial position
    const initP = getPathPoint(workoutData.workouts.length);
    avatar.x = initP.x;
    avatar.y = initP.y;

    // ===== PARALLAX LAYERS =====
    const bgLayers = [
        { color: '#1E2340', factor: 0.05, y: -3, h: 12 },
        { color: '#2A3355', factor: 0.15, y: 1, h: 8 },
        { color: '#1B4D3E', factor: 0.3, y: 4, h: 6 },
        { color: '#2D5A4A', factor: 0.5, y: 7, h: 5 }
    ];

    // ===== FLOATING PARTICLES =====
    const PARTICLE_COLORS = ['rgba(255,215,0,0.3)','rgba(0,212,255,0.25)','rgba(77,230,128,0.25)','rgba(255,107,157,0.2)','rgba(168,85,247,0.2)'];
    let particles = [];
    for (let i = 0; i < 40; i++) {
        particles.push({
            x: (Math.random() - 0.5) * 40,
            y: (Math.random() - 0.5) * 20,
            size: 2 + Math.random() * 6,
            speed: 0.2 + Math.random() * 0.8,
            phase: Math.random() * Math.PI * 2,
            color: PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)]
        });
    }

    // ===== CONFETTI =====
    let confettiParticles = [];

    function spawnConfetti() {
        const colors = ['#4DE680','#00D4FF','#FFD700','#FF6B9D','#A855F7','#FF8C42'];
        for (let i = 0; i < 60; i++) {
            const el = document.createElement('div');
            el.className = 'confetti';
            el.style.left = Math.random() * 100 + 'vw';
            el.style.background = colors[Math.floor(Math.random() * colors.length)];
            el.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
            el.style.width = (6 + Math.random() * 8) + 'px';
            el.style.height = (6 + Math.random() * 8) + 'px';
            el.style.animationDelay = (Math.random() * 2) + 's';
            el.style.animationDuration = (2 + Math.random() * 2) + 's';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 5000);
        }
    }

    // ===== WORLD TO SCREEN =====
    function worldToScreen(wx, wy) {
        const sx = (wx - camera.x) * camera.zoom * 40 + W / 2;
        const sy = -(wy - camera.y) * camera.zoom * 40 + H / 2;
        return { x: sx, y: sy };
    }

    function screenToWorld(sx, sy) {
        const wx = (sx - W / 2) / (camera.zoom * 40) + camera.x;
        const wy = -((sy - H / 2) / (camera.zoom * 40)) + camera.y;
        return { x: wx, y: wy };
    }

    // ===== INPUT =====
    let touches = [];
    let lastPinchDist = 0;

    canvas.addEventListener('pointerdown', (e) => {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        lastDragX = e.clientX;
        lastDragY = e.clientY;
        camera.velX = 0;
        camera.velY = 0;
        autoFollow = false;
        autoFollowTimer = 0;
    });

    canvas.addEventListener('pointermove', (e) => {
        if (!isDragging) return;
        const dx = (e.clientX - lastDragX) / (camera.zoom * 40);
        const dy = (e.clientY - lastDragY) / (camera.zoom * 40);
        camera.x -= dx;
        camera.y += dy;
        camera.velX = -dx;
        camera.velY = dy;
        lastDragX = e.clientX;
        lastDragY = e.clientY;
    });

    canvas.addEventListener('pointerup', () => {
        isDragging = false;
        autoFollowTimer = Date.now();
    });

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        camera.zoom = Math.max(0.3, Math.min(3, camera.zoom * zoomDelta));
        autoFollow = false;
        autoFollowTimer = Date.now();
    }, { passive: false });

    // Touch pinch zoom
    canvas.addEventListener('touchstart', (e) => {
        touches = [...e.touches];
        if (touches.length === 2) {
            lastPinchDist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
        }
    }, { passive: true });

    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            if (lastPinchDist > 0) {
                const scale = dist / lastPinchDist;
                camera.zoom = Math.max(0.3, Math.min(3, camera.zoom * scale));
            }
            lastPinchDist = dist;
        }
    }, { passive: true });

    canvas.addEventListener('touchend', () => {
        lastPinchDist = 0;
    });

    // ===== UI EVENTS =====
    document.getElementById('btn-workout').addEventListener('click', () => {
        workoutData.workouts.push({
            date: new Date().toISOString(),
            type: WORKOUT_TYPES[Math.floor(Math.random() * WORKOUT_TYPES.length)],
            duration: 20 + Math.floor(Math.random() * 70)
        });
        saveData();
        updateAvatarTarget();
        avatar.isMoving = true;
        autoFollow = true;

        // Check milestones
        const count = workoutData.workouts.length;
        MILESTONES.forEach((m, i) => {
            if (count === m && !reachedMilestones.includes(m)) {
                reachedMilestones.push(m);
                saveData();
                setTimeout(() => showMilestone(m, i), 800);
            }
        });

        updateUI();
    });

    document.getElementById('btn-focus').addEventListener('click', () => {
        autoFollow = true;
        camera.zoom = 1;
    });

    document.getElementById('btn-start').addEventListener('click', () => {
        autoFollow = false;
        camera.x = 0;
        camera.y = 0;
        camera.zoom = 0.6;
    });

    document.getElementById('btn-screenshot').addEventListener('click', () => {
        // Hide UI, capture, show UI
        document.getElementById('ui-overlay').style.display = 'none';
        requestAnimationFrame(() => {
            canvas.toBlob((blob) => {
                document.getElementById('ui-overlay').style.display = '';
                if (navigator.share && blob) {
                    const file = new File([blob], 'BeOnTrack-Journey.png', { type: 'image/png' });
                    navigator.share({ title: 'Meine BeOnTrack Journey', files: [file] }).catch(() => {});
                } else if (blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'BeOnTrack-Journey.png';
                    a.click();
                    URL.revokeObjectURL(url);
                }
            });
        });
    });

    function showMilestone(count, index) {
        const popup = document.getElementById('milestone-popup');
        document.getElementById('milestone-title').textContent = count + ' Workouts!';
        document.getElementById('milestone-title').style.color = MILESTONE_COLORS[index];
        document.getElementById('milestone-text').textContent = getMilestoneMessage(count);
        popup.classList.add('show');
        spawnConfetti();
    }

    function closeMilestone() {
        document.getElementById('milestone-popup').classList.remove('show');
    }

    function getMilestoneMessage(count) {
        const msgs = {
            1: 'Der erste Schritt ist getan!',
            5: 'Fuenf geschafft - Routine beginnt!',
            10: 'Zweistellig - du bist dabei!',
            25: 'Viertel-Hundert - stark!',
            50: 'Halbzeit zum Club der 100!',
            75: 'Drei Viertel - nicht aufhoeren!',
            100: 'HUNDERT! Du bist eine Maschine!',
            150: 'Absoluter Wahnsinn!',
            200: 'Zweihundert - Respekt!',
            365: 'Ein ganzes Jahr - LEGENDE!'
        };
        return msgs[count] || 'Meilenstein erreicht!';
    }

    function updateUI() {
        const count = workoutData.workouts.length;
        document.getElementById('workout-count').textContent = count;
        document.getElementById('streak-count').textContent = calcStreak();
        document.getElementById('distance-count').textContent = (count * STEP_SIZE).toFixed(0) + 'm';
    }
    updateUI();

    // ===== RENDER =====
    let lastTime = 0;

    function drawFrame(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;

        ctx.clearRect(0, 0, W, H);

        // Auto-follow timeout
        if (!autoFollow && autoFollowTimer > 0 && Date.now() - autoFollowTimer > 4000) {
            autoFollow = true;
        }

        // Camera follow avatar
        if (autoFollow && !isDragging) {
            camera.x += (avatar.x - camera.x) * 3 * dt;
            camera.y += (avatar.y - camera.y) * 3 * dt;
        } else if (!isDragging) {
            camera.x += camera.velX * 0.95;
            camera.y += camera.velY * 0.95;
            camera.velX *= 0.95;
            camera.velY *= 0.95;
        }

        // ---- BACKGROUND LAYERS ----
        bgLayers.forEach(layer => {
            const offsetX = camera.x * layer.factor * camera.zoom * 40;
            const screenY = -(layer.y - camera.y) * camera.zoom * 40 + H / 2;
            const layerH = layer.h * camera.zoom * 40;

            ctx.fillStyle = layer.color;
            ctx.fillRect(0, screenY, W, layerH);
        });

        // ---- FLOATING PARTICLES ----
        particles.forEach(p => {
            p.x += 0.1 * dt;
            p.y += Math.sin(time * 0.001 * p.speed + p.phase) * 0.02;

            // Respawn
            if (p.x > camera.x + 25) p.x = camera.x - 25;
            if (p.x < camera.x - 25) p.x = camera.x + 25;

            const sp = worldToScreen(p.x, p.y);
            if (sp.x < -20 || sp.x > W + 20 || sp.y < -20 || sp.y > H + 20) return;

            const alpha = Math.abs(Math.sin(time * 0.001 * p.speed * 0.5 + p.phase)) * 0.4;
            const size = p.size * camera.zoom;

            ctx.beginPath();
            ctx.arc(sp.x, sp.y, size, 0, Math.PI * 2);
            ctx.fillStyle = p.color.replace(/[\d.]+\)$/, alpha + ')');
            ctx.fill();
        });

        // ---- PATH ----
        const totalSteps = workoutData.workouts.length;
        const maxDraw = totalSteps + 20;

        // Future path (faded)
        if (maxDraw > totalSteps) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = Math.max(6, 18 * camera.zoom);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (let t = totalSteps; t <= maxDraw; t += 0.5) {
                const p = getPathPoint(t);
                const sp = worldToScreen(p.x, p.y);
                if (t === totalSteps) ctx.moveTo(sp.x, sp.y);
                else ctx.lineTo(sp.x, sp.y);
            }
            ctx.stroke();
        }

        // Walked path (gradient)
        if (totalSteps > 0) {
            for (let t = 0; t < totalSteps; t += 0.3) {
                const p = getPathPoint(t);
                const sp = worldToScreen(p.x, p.y);
                const p2 = getPathPoint(t + 0.3);
                const sp2 = worldToScreen(p2.x, p2.y);

                const progress = t / Math.max(totalSteps, 1);
                const r = Math.round(77 + (0 - 77) * progress);
                const g = Math.round(230 + (212 - 230) * progress);
                const b = Math.round(128 + (255 - 128) * progress);

                ctx.beginPath();
                ctx.moveTo(sp.x, sp.y);
                ctx.lineTo(sp2.x, sp2.y);
                ctx.strokeStyle = `rgb(${r},${g},${b})`;
                ctx.lineWidth = Math.max(8, 22 * camera.zoom);
                ctx.lineCap = 'round';
                ctx.stroke();

                // Glow
                ctx.beginPath();
                ctx.moveTo(sp.x, sp.y);
                ctx.lineTo(sp2.x, sp2.y);
                ctx.strokeStyle = `rgba(${r},${g},${b},0.2)`;
                ctx.lineWidth = Math.max(16, 40 * camera.zoom);
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        // ---- MILESTONES ----
        MILESTONES.forEach((m, i) => {
            if (m > maxDraw) return;
            const p = getPathPoint(m);
            const sp = worldToScreen(p.x, p.y);
            const reached = reachedMilestones.includes(m);
            const color = MILESTONE_COLORS[i];
            const flagSize = camera.zoom * 20;

            // Flag pole
            ctx.beginPath();
            ctx.moveTo(sp.x, sp.y);
            ctx.lineTo(sp.x, sp.y - flagSize * 3);
            ctx.strokeStyle = reached ? color : 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2 * camera.zoom;
            ctx.stroke();

            // Flag
            ctx.beginPath();
            ctx.moveTo(sp.x, sp.y - flagSize * 3);
            ctx.lineTo(sp.x + flagSize * 1.5, sp.y - flagSize * 2.3);
            ctx.lineTo(sp.x, sp.y - flagSize * 1.6);
            ctx.fillStyle = reached ? color : 'rgba(255,255,255,0.1)';
            ctx.fill();

            // Number
            ctx.fillStyle = reached ? '#fff' : 'rgba(255,255,255,0.3)';
            ctx.font = `bold ${Math.max(10, 12 * camera.zoom)}px -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(m, sp.x, sp.y + flagSize * 1.5);

            // Pulsing circle if reached
            if (reached) {
                const pulse = Math.sin(time * 0.003 + i) * 0.3 + 0.7;
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, 8 * camera.zoom * pulse, 0, Math.PI * 2);
                ctx.fillStyle = color + '40';
                ctx.fill();
            }
        });

        // ---- AVATAR ----
        // Move avatar towards target
        const dx = avatar.targetX - avatar.x;
        const dy = avatar.targetY - avatar.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.05) {
            avatar.x += dx * 4 * dt;
            avatar.y += dy * 4 * dt;
            avatar.isMoving = true;
            avatar.bounce += dt * 12;
        } else {
            avatar.isMoving = false;
            avatar.breathe += dt * 2;
        }

        const asp = worldToScreen(avatar.x, avatar.y);
        const aSize = camera.zoom * 18;
        const bounceY = avatar.isMoving ? Math.abs(Math.sin(avatar.bounce)) * aSize * 0.5 : Math.sin(avatar.breathe) * 2;
        const squash = avatar.isMoving ? 1 + Math.sin(avatar.bounce) * 0.1 : 1;

        // Glow
        const glowGrad = ctx.createRadialGradient(asp.x, asp.y - bounceY, aSize * 0.5, asp.x, asp.y - bounceY, aSize * 2.5);
        glowGrad.addColorStop(0, 'rgba(77, 230, 128, 0.25)');
        glowGrad.addColorStop(1, 'rgba(77, 230, 128, 0)');
        ctx.beginPath();
        ctx.arc(asp.x, asp.y - bounceY, aSize * 2.5, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();

        // Body
        ctx.save();
        ctx.translate(asp.x, asp.y - bounceY);
        ctx.scale(1 / squash, squash);

        // Main circle
        const bodyGrad = ctx.createRadialGradient(-aSize * 0.2, -aSize * 0.2, aSize * 0.1, 0, 0, aSize);
        bodyGrad.addColorStop(0, '#6FF59A');
        bodyGrad.addColorStop(1, '#2DD866');
        ctx.beginPath();
        ctx.arc(0, 0, aSize, 0, Math.PI * 2);
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        // Eyes
        const eyeOff = aSize * 0.3;
        const eyeSize = aSize * 0.2;
        ctx.fillStyle = '#141828';
        ctx.beginPath();
        ctx.arc(-eyeOff, -aSize * 0.1, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeOff, -aSize * 0.1, eyeSize, 0, Math.PI * 2);
        ctx.fill();

        // Eye highlights
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-eyeOff + eyeSize * 0.3, -aSize * 0.1 - eyeSize * 0.3, eyeSize * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeOff + eyeSize * 0.3, -aSize * 0.1 - eyeSize * 0.3, eyeSize * 0.35, 0, Math.PI * 2);
        ctx.fill();

        // Smile
        ctx.beginPath();
        ctx.arc(0, aSize * 0.15, aSize * 0.4, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.strokeStyle = '#141828';
        ctx.lineWidth = aSize * 0.08;
        ctx.lineCap = 'round';
        ctx.stroke();

        ctx.restore();

        // ---- TRAIL behind avatar ----
        if (avatar.isMoving) {
            for (let i = 0; i < 3; i++) {
                const trailP = getPathPoint(workoutData.workouts.length - 0.5 - i * 0.5);
                const tsp = worldToScreen(trailP.x, trailP.y);
                ctx.beginPath();
                ctx.arc(tsp.x, tsp.y, (3 - i) * camera.zoom * 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(77,230,128,${0.3 - i * 0.1})`;
                ctx.fill();
            }
        }

        requestAnimationFrame(drawFrame);
    }

    requestAnimationFrame(drawFrame);
    </script>
</body>
</html>
